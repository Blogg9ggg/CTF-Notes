### 介绍
栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。栈溢出的基本前提:
* 程序必须向栈上写入数据
* 写入的数据大小没有被良好地控制  
  
栈溢出的核心步骤:  
* 寻找危险函数  
  常见的危险函数如下:
  * 输入
    * gets, 直接读取一行, 忽略 '\x00'
    * scanf
    * vscanf
  * 输出
    * sprintf
  * 字符串
    * strcpy, 字符串复制, 遇到 '\x00' 停止
    * strcat, 字符串拼接, 遇到 '\x00' 停止
    * bcopy
* 确定填充长度  
  这一部分主要是计算我们所要操作的地址与我们所要覆盖的地址的距离. 常见的操作方法就是打开 IDA, 根据其给定的地址计算偏移. 一般变量会有以下几种索引模式:  
  * 相对于栈基地址的索引, 可以直接通过查看 EBP 相对偏移获得
  * 相对应栈顶指针的索引, 一般需要设置断点进行调试, 转换成相对于栈基地址的索引来求解
  * 直接地址索引, 就相当于直接给定了地址  
  
  一般来说, 我们会有如下的覆盖需求:  
  * **覆盖函数返回地址**, 这时候直接看 EBP 即可
  * **覆盖栈上某个变量的内容**, 这时候就需要更加精细的计算了
  * **覆盖 bss 段某个变量的内容**
  * 根据现实执行情况, 覆盖特定的变量或地址的内容

   覆盖某个地址的目的是想通过覆盖地址的方法来直接或者间接地控制程序执行流程.

### ROP(Return Oriented Programming)
ROP 的主要思想是在栈缓冲区溢出的基础上, 利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值, 从而控制程序的执行流程. 所谓 gadgets 就是以 ret 结尾的指令序列, 通过这些指令序列, 我们可以修改某些地址的内容, 方便控制程序的执行流程. 之所以称之为 ROP, 是因为其核心在于利用指令集中的 ret 指令, 改变指令流的执行顺序. ROP 攻击一般得满足如下条件:  
* 程序存在溢出, 并且可以控制返回地址;
* 可以找到满足条件的 gadgets 以及相应 gadgets 的地址.  
  
如果 gadgets 每次的地址是不固定的, 那我们就需要想办法动态获取对应的地址了.

1. **ret2text**  
  ret2text 即控制程序执行程序本身已有的代码 (.text). 我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (即 gadgets), 这就是 ROP.  
  例题: ./problem/ret2text

2. **ret2shellcode**
3. **ret2syscall**
4. **ret2libc**
